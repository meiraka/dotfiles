
PROMPT2=". "
SPROMPT='%{$suggest%}%B%r%b [y, n, a, e] > '
ZLE_RPROMPT_INDENT=0

local keymap="main"
function mode_color() {
    case "${keymap}" in
        vicmd)
            case "${REGION_ACTIVE}" in
                1)
                    echo 'magenta'
                    ;;
                2)
                    echo 'magenta'
                    ;;
                *)
                    echo 'blue'
                    ;;
            esac
        ;;
        main)
            echo 'green'
            ;;
        visual)
            echo 'magenta'
            ;;
        *)
            echo 'red'
            ;;
    esac
}


local prompt_arrow="❱ "
function update_prompt() {
    local val
    local color="$(mode_color)"
    PROMPT="%F{${color}}${prompt_arrow}%f"
    if [ "${VCS}" != "" ]; then
        RPROMPT="${val}%F{black}%f%K{black}%F{${color}} $(vcs_icon) ${VCS_REPO} %k%f%K{${color}}%F{black} ${VCS_BRANCH} %k%f"
    else
        RPROMPT=""
    fi
    zle reset-prompt
}

function vcs_icon() {
    case "${VCS}" in
        git)
            if [[ "${VCS_REPO}" == *"ghe"* ]] || [[ "${VCS_REPO}" == *"github"* ]]; then
                echo ""
                return
            fi
            echo ""
            ;;
        *)
            echo ""
            ;;
    esac
}

function zle-line-init zle-keymap-select {
    keymap="${KEYMAP}"
    update_prompt
}

zle -N zle-line-init
zle -N zle-keymap-select

autoload -U add-zle-hook-widget
add-zle-hook-widget zle-line-pre-redraw update_prompt

function set_user_var() {
   printf "\033]1337;SetUserVar=%s=%s\007" $1 `echo -n $2 | base64`
}

autoload -Uz add-zsh-hook
add-zsh-hook precmd env_vcs_info_async
local VCS=""
local VCS_REPO=""
local VCS_BRANCH=""

function env_vcs_info_async() {
    local lastcmd="${history[@][1]}"
    if [ "${lastcmd[0,3]}" != "git" ] && [ "${lastcmd[0,2]}" != "cd" ]; then
        return
    fi
    async_stop_worker env_vcs_info
    async_start_worker env_vcs_info -n
    async_register_callback env_vcs_info env_vcs_info_callback
    async_job env_vcs_info env_vcs_info_out
}

function env_vcs_info_out() {
    if [ "$(git rev-parse --is-inside-work-tree 2> /dev/null)" = "true" ]; then
        echo "git$(git config --get remote.origin.url)$(git rev-parse --abbrev-ref HEAD)"
        return
    fi
    echo ""
}

function env_vcs_info_callback() {
    local val=(${(s//)3})
    VCS=$val[1]
    VCS_REPO=$val[2]
    VCS_BRANCH=$val[3]
    set_user_var VCS "${VCS}"
    set_user_var VCS_REPO "${VCS_REPO}"
    set_user_var VCS_BRANCH "${VCS_BRANCH}"
    update_prompt
}

add-zsh-hook precmd env_kube_info_async
local KUBE_CONTEXT=""
local KUBE_NAMESPACE=""
local kubeconfig_last_modified=''

function env_kube_info_async() {
    local last_modified="$(date -r ~/.kube/config 2> /dev/null)"
    if [ "$kubeconfig_last_modified" = "$last_modified" ]; then
        return
    fi
    kubeconfig_last_modified="$last_modified"
    async_stop_worker env_kube_info
    async_start_worker env_kube_info -n
    async_register_callback env_kube_info env_kube_info_callback
    async_job env_kube_info env_kube_info_out
}

function env_kube_info_out() {
    local context ns
    if context=$(kubectl config current-context 2>/dev/null); then
        ns=$(kubectl config view -o "jsonpath={.contexts[?(@.name==\"$context\")].context.namespace}")
        echo "${context}${ns}"
    else
        echo ""
    fi
}

function env_kube_info_callback() {
    local val=(${(s//)3})
    KUBE_CONTEXT=$val[1]
    KUBE_NAMESPACE=$val[2]
    set_user_var KUBE_CONTEXT "${KUBE_CONTEXT}"
    set_user_var KUBE_NAMESPACE "${KUBE_NAMESPACE}"
}
